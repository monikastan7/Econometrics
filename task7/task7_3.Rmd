---
title: "Task7_3"
author: "Monika Stanislovėnaitė, EKO"
date: "2016-04-05"
output: html_document
---
---
[@Hyndman2014a, ch. 2. The forecaster’s toolbox, Lab Session 2]

**Lab Session 2, užduotis nr. 3**
For the data set **bricksq**:

(a) Split the data into two parts using:
```bricks1 <- window(bricksq, end=1987.99);
bricks2 <- window(bricksq, start=1988)```

(b) Check that your data have been split appropriately by producing the following plot:
```plot(bricksq);
lines(bricks1,col="red");
lines(bricks2,col="blue")```

(c) Calculate forecasts using each of the four benchmark methods applied to *bricks1*.

(d) Compare the accuracy of your forecasts against the actual values stored in *bricks2*. For example:
```f1 <- meanf(bricks1);
accuracy(f1,bricks2)```

(e) Which method does best? Why?

(f) For the best method, compute the residuals and plot them. For example:
```res <- residuals(f1);
plot(res);
hist(res, breaks="FD");
Acf(res)```
Do the residuals appear to be uncorrelated and normally distributed?



Užduočiai reikės paketo **fpp**:
```{r}
library(fpp)
```

Naudosime duomenis *bricksq*:
```{r}
duom <- bricksq
```

(a) We will split the data into two parts:
```{r}
bricks1 <- window(bricksq, end=1987.99)
bricks2 <- window(bricksq, start=1988)
```

(b) We will check that data have been split appropriately by producing the following plot:
```{r}
plot(bricksq)
lines(bricks1,col="red")
lines(bricks2,col="blue")
```

(c) We will calculate forecasts using each of the four benchmark methods applied to *bricks1*:
```{r}
##isbandysime visus metodus - drift, mean, naive ir seasonal naive.
#mean metodas (forecast of all future values is equal to mean of historical data):
fmean <- meanf(bricks1, h=27)
#naive metodas (forecasts equal to last observed value):
fnaive <- naive(bricks1, h=27)
#seasonal naive metodas (forecasts equal to last value from same season):
fsnaive <- snaive(bricks1, h=27)
#drift metodas (forecasts equal to last value plus average change):
fdrift <- rwf(bricks1, drift=TRUE, h=27)
```

(d) We will compare the accuracy of forecasts against the actual values stored in *bricks2*:
```{r}
accuracy(fmean, bricks2)
accuracy(fnaive, bricks2)
accuracy(fsnaive, bricks2)
accuracy(fdrift, bricks2)
```

(e) Which method does best? Why?
Geriausias metodas prognozavimui šiuo atveju yra **seasonal naive** metodas, nes jis turi mažiausius RMSE, MAE, MAPE, MASE. Taip pat iš grafiko galime pastebėti, kad duomenys yra sezoniniai, o **seasonal naive** metodas ir atsižvelgia į sezoniškumą.Kad yra kasmetinis sezoniškumas galime įsitikinti ir su *ACF*:
```{r}
acf(duom)
#"pikai" ties 1, 2, 3, ...
```

(f) For the best method, compute the residuals and plot them. Do the residuals appear to be uncorrelated and normally distributed?
```{r}
res <- residuals(fsnaive)
plot(res)
hist(res, breaks="FD") #iš grafiko atrodo, kad liekanos normaliai pasiskirsčiusios
shapiro.test(res) # tačiau pritaikę testą gauname, kad liekanos nėra normalios
Acf(res) #for uncorrelated data, we would expect each autocorrelation to be close to 0
#95% reikšmių turėtų neišeiti už kritinių reikšmių ribų, iš ACF matome, kad nemažai reikšmių išeina už krinitių reikšmių, tai greičiausiai liekanos yra koreliuotos.
```
